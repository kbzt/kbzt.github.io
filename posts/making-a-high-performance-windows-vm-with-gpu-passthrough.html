<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KB - Blog</title>
	<link rel="stylesheet" href="/css/index/style.css">
	<link rel="stylesheet" type="text/css" href="/css/blog/post.css">
    <link rel="icon" href="/assets/images/favicon-16x16.png">
    <meta name="description" content="Developer, music lover, linux nerd, and overall computing enthusiast">
    <meta property="og:title" content="KB - Blog">
    <meta property="og:description" content="Developer, music lover, linux nerd, and overall computing enthusiast">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Kleidi Bujari">
    <meta name="author" content="Kleidi Bujari">
</head>
<body>

	<div class="banner"></div>
	<div class="container">

		<div class="info">
			<p>Jan 15, 2022</p> <span>|</span>
			<a href="./" class="blog-link">Back to Posts</a><span>|</span>
			<p>Length: Medium</p>
		</div>
		
		<div class="title">Making a high performance Windows 10 VM with GPU-Passthrough</div>
		
		<div>
			<p class="text-body">
				In early 2021, I transitioned my personal computers to Arch Linux and while the
				experience has been excellent overall, there are a few shortcomings in the 
				software compatibility department, mainly with a few games (League of Legends)
				and software I need to use for school (Multisim). While these can be "run" using
				wine, I found that the experience left a lot to be desired, and for school especially,
				I wanted to make sure I was in an environment supported by my classes.

				<br>
				<br>

				This led to the decision to use Windows for these as well as anything else not 
				supported well by linux. At this point you might be asking why I'm not just 
				dual-booting for simplicity. The main reasons are that I've gotten annoyed with
				a lot of the telemetry, excess, and clunkiness of running Windows natively on my
				desktop as well as for the sake of getting some experience with QEMU/KVM on Linux. 
				Note that this won't be a full guide to the process, but more of a showcase on how 
				I set it up for myself.
				
				<br>
				<br>

				Feel free to use anything mentioned here for yourself and be sure to follow along with 
				the files mentioned by viewing them yourself on my 
				<a href="https://github.com/kleidibujari/virt-machine" target="_blank" class="blog-link">github.</a> 
				Without further rambling, let's get into the important parts.
			</p>

			<p class="subtitle">Hardware & Specifics</p>

			<p class="text-body">
				<strong>CPU:</strong> AMD Ryzen 7 3700x <br>
				<strong>RAM:</strong> 16GB DDR4 3600MHz <br>
				<strong>GPU:</strong> EVGA RTX 2080 XC Gaming <br>

				<br>

				While most hardware choices don't really matter for this kind of virtualization, eg. get
				as much memory as you can, have a processor with a lot of threads; one recommendation I
				can make is to not get an Nvidia GPU. Not only is this good advice for anyone looking to
				transition to a Linux desktop due to proprietary drivers and other headaches, but it plays 
				a large part in the complexity of this setup as I painfully learned trying to figure out 
				why the VM wouldn't start when I first set it up, more on this later.

				<br>
				<br>

				Other than that, my experience was pretty standard. Setting up a VM through virt-manager and
				libvirt was the same process as any other type of VM. I installed Windows normally using the
				default video drivers provided by QEMU and virtio drivers for disks, network, etc, before doing
				anything GPU related to make sure any errors I had to solve later weren't related to the VM itself.
			</p>

			<p class="subtitle">GPU Passthrough</p>

			<p class="text-body">
				Since I only have one graphics output in my system and no extra PCIe slots, the process of passing
				through a GPU does change slightly from keeping a graphics card for the host machine. What stays
				the same is dumping your GPU vBios to a file, and in the case of Nvidia, hex-editing the beginning of 
				the file.

				<img src="./assets/gpu-hex.png" alt="" style="width: 100%;">
				
				Above is my <a href="https://github.com/kleidibujari/virt-machine/blob/main/GPU.rom" target="_blank" class="blog-link">edited vBios file</a> 
				that is passed through to the VM. Usually, when you load into a graphical session, the vBios gets 
				changed as you use the GPU. Because of this, a new vBios is given to the VM to use. Next, to add 
				the GPU alongside any other devices such as a USB controller, I had to get the relevant IOMMU groups. \
				Here's an example of what the GPU group looked like on my system:

				<br>
				<br>

				<img src="./assets/lspci.png" alt="" style="width: 100%">
				
				<br>
				<br>

				These were added to the <a href="https://github.com/kleidibujari/virt-machine/blob/main/win10.xml" target="_blank" class="blog-link">xml file</a> containing all the information for the VM.
				
				<br>
				<br>

				Now that the normal setup is done, we can move on to specifics in a single GPU setup. The idea is 
				for this process is generally as follows:

				<br>
				<br>

				<ol class="text-body">
					<li>Stop the host display server</li>
					<li>Unload all GPU drivers</li>
					<li>Load the vfio kernel modules in their place</li>
				</ol>

				<br>
				<br>
			</p>

			<p class="text-body">
				This is accomplished with scripts that are triggered by the VM starting and stopping. Naturally,
				<a href="https://github.com/kleidibujari/virt-machine/blob/main/start.sh" target="_blank" class="blog-link">start.sh</a> 
				handles startup, with the IOMMU groups sourced from <a href="https://github.com/kleidibujari/virt-machine/blob/main/kvm.conf" target="_blank" class="blog-link">kvm.conf</a>. 
				Lucky for me, you only need to edit the vBios file on Nvidia GPUs. Most documention said this 
				was only required for pascal series (eg. GTX 1070), however, I was unable to get the VM to 
				properly boot without this step. Keep that in mind if you plan on having a similar setup.  
			</p>

			<p class="subtitle">Optimization</p>

			<p class="text-body">
				Now that I had a working VM, the next goal was to reduce any latency and overhead from virtualising 
				Windows. Since I planned to play some competitive games that don't run on linux, it was important to
				me to make it feel like I was playing on bare metal. The main things I used for this were CPU Pinning
				and HugePages (<a href="https://wiki.archlinux.org/title/KVM#Enabling_huge_pages" target="_blank" class="blog-link">Arch Wiki</a>).
				CPU pinning manually allocates certain threads to the VM so the host doesn't use them as well, introducing 
				latency. This is configured on a per-CPU basis since every processor has it's own architechture. In my
				case, the Ryzen 7 3700x has the following layout:

				<br>
				<br>

				<img src="./assets/lstopo.png" alt="" style="margin-left: 20%; width: 60%; border-radius: 5px;">

				<br>
				<br>

				The important sections to look at are the grey boxes which represent a physical core, and the group of 
				grey boxes itself which represents a CCX (Core Complex). I chose to only include cores from one of the 
				two CCX present on the CPU. Since the VM will only be used for gaming and schoolwork, 8 threads should be
				more than enough performance. Using only one CCX will also improve latency since the cores won't have to 
				wait on information from the other CCX. Lastly, I chose the second or bottom CCX since I want to leave 
				Core #0 for the host. All of this can be seen in the <a href="https://github.com/kleidibujari/virt-machine/blob/main/win10.xml" target="_blank" class="blog-link">xml file,</a> 
				specifically in the "cputune" section.
				
				<br>
				<br>

				The last major optimization I included was HugePages. Without going into too much detail, it is an alternate
				way of providing memory to the VM, which results in a massive difference in performance according to my
				testing. It is manually allocated using the scripts triggered at startup and deallocated upon closing the VM.
				I stronly recommend looking into HugePages if you decide to use a setup like this. There were a few other 
				small optimizations that I applied and you might be able to find in the xml file, but they didn't provide enough
				of a difference to be meaningful in my opinion.
			</p>

			<p class="subtitle">Hyper-V</p>

			<p class="text-body">
				Hyper-V is a virtualization platform on Windows, and it's normally used in this case to hide the nature of the
				host to the guest machine. In other words, you can use it to hide the fact that you are using a VM to circumvent
				some anti-cheats and other software restrictions. I chose not to use it in my setup due to the performance hit as 
				well as not really needing it for anything I use Windows for. Note that games like Valorant have been updated to 
				automatically flag Hyper-V users, but it can work for other titles with a similar anti-cheat.
			
				<br>
				<br>

				So far this setup has treated me very well, and I can't see myself needing to run Windows natively for the forseeable
				future. If you want to talk to me further about anything here, feel free to <a href="mailto:mail@kleidi.ca" class="blog-link">contact</a>
				me.
			</p>
			
		</div>
	</div>

	<div class="footer">
      
        <div class="links">
            <h3 class="footer-header">info</h3>
            <a href="https://github.com/kbzt" target="_blank" class="link">github</a>
            <a href="mailto:mail@kleidi.ca" target="_blank" class="link">mail</a>
            <a href="/resume.pdf" target="_blank" class="link">resume</a>
        </div>

        <div class="site">
            <h3 class="footer-header">site</h3>
            <a href="/" class="link">homepage</a>
            <a href="/posts/" class="link">posts</a>
            <a href="/projects/" class="link">projects</a>
        </div>
        
        <div class="extras">
            <h3 class="footer-header">extras</h3>
            <a href="/key.txt" class="link" target="_blank">pgp key</a>
            <a href="https://github.com/kbzt/kbzt.github.io" class="link" target="_blank">source</a>
            <a href="https://github.com/morhetz/gruvbox" target="_blank" class="link">colors</a>
            <a href="https://github.com/bBoxType/FiraSans" class="link" target="_blank">font</a>
        </div>

    </div>
</body>
</html>